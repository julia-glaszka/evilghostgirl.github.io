{"hash":"d7854f84d1ae0307c2d5336bcf545aa865f01b3e","data":{"post":{"title":"Wykonywanie kopii obiektów w javascript","path":"/wykonywanie-kopii-obiektow-w-javascript/","slug":"wykonywanie-kopii-obiektow-w-js","datetime":"2020-03-01 14:43:24","content":"<p><strong>Kopiowanie</strong> to mechanizm tworzenia <strong>duplikatów</strong>. W przypadku <strong>prymitywów</strong> (string, number, boolean itd) sprawa jest prosta, możemy spokojnie wykonywać wszystkie operacje bez obaw o nadpisywanie oryginału. </p>\n<p>Sprawa się komplikuje przy zastosowaniu przypisania obiektu za pomocą prostego = - wtedy tworzy się <strong>referencja</strong> do oryginału. Kopia jest zależna od oryginału, więc każda modyfikacja w obiekcie oddziałuje na resztę obiektów. Czasami taki efekt nie jest pożądany, niestety w js brakuje natywnych, prostych sposobów na klonowanie obiektów bez tworzenia referencji (wskaźnika na oryginał), trzeba w tym celu wykorzystywać różne hacki. </p>\n<p>W tym artykule omówię część z nich, mam nadzieję że komuś się przydadzą.</p>\n<h2 id=\"trochę-teorii\">Trochę teorii</h2>\n<p>Istnieją rodzaje kopiowania obiektów w js:</p>\n<ul>\n<li><strong>Brak</strong> - <strong>referencja</strong>, wskazuje na adres obiektu macierzystego. Przy podmianie jakiejkolwiek wartości obiektu, zamieniają się one równocześnie w kopii i oryginale. Kopia jest <strong>silnie zależna</strong> od oryginału.</li>\n<li><strong>Płytkie (shallow)</strong> - otrzymujemy prostą kopię, która posiada <strong>jednopoziomową kopię</strong>, głębsze zagnieżdzenia są <strong>referencją do oryginału</strong> i przy podmianie wartości zmieni się również w innych obiektach.</li>\n<li><strong>Głębokie (deep)</strong> - kopie są <strong>identyczne</strong> i <strong>niezależne</strong> od siebie. Obiekt jest <strong>autonomiczny</strong>, posiada wartości na własność, <strong>nic nie współdzieli</strong> - zmiana w oryginale nie zmodyfikuje kopii.</li>\n</ul>\n<h2 id=\"brak-kopii\">Brak kopii</h2>\n<p>Zacznijmy od tego, w jaki sposób nie skopiujemy obiektu, a który jednak początkowo wydaje się słusznym i prostym rozwiązaniem. Jak widać, przy podmianie wartości w klonie, wartość oryginału również się zmieniła, co nie jest oczekiwanym efektem.</p>\n<pre class=\"shiki\" style=\"background-color: #000000\"><code><span style=\"color: #7CA668\">// proste przypisanie  </span>\n<span style=\"color: #569CD6\">var</span><span style=\"color: #FFFFFF\"> strawberry </span><span style=\"color: #D4D4D4\">=</span><span style=\"color: #FFFFFF\"> {</span>\n<span style=\"color: #FFFFFF\">    color: </span><span style=\"color: #CE9178\">'red'</span><span style=\"color: #FFFFFF\">,</span>\n<span style=\"color: #FFFFFF\">    taste: </span><span style=\"color: #CE9178\">'sweet'</span><span style=\"color: #FFFFFF\">,</span>\n<span style=\"color: #FFFFFF\">    size: </span><span style=\"color: #CE9178\">'large'</span><span style=\"color: #FFFFFF\">,</span>\n<span style=\"color: #FFFFFF\">    shape: {</span>\n<span style=\"color: #FFFFFF\">        x: </span><span style=\"color: #B5CEA8\">10</span><span style=\"color: #FFFFFF\">,</span>\n<span style=\"color: #FFFFFF\">        y: </span><span style=\"color: #B5CEA8\">32</span><span style=\"color: #FFFFFF\">,</span>\n<span style=\"color: #FFFFFF\">        z: </span><span style=\"color: #B5CEA8\">33</span>\n<span style=\"color: #FFFFFF\">    }</span>\n<span style=\"color: #FFFFFF\">};</span>\n\n<span style=\"color: #569CD6\">var</span><span style=\"color: #FFFFFF\"> someOtherStrawberry </span><span style=\"color: #D4D4D4\">=</span><span style=\"color: #FFFFFF\"> strawberry;</span>\n<span style=\"color: #FFFFFF\">someOtherStrawberry.size </span><span style=\"color: #D4D4D4\">=</span><span style=\"color: #FFFFFF\"> </span><span style=\"color: #CE9178\">'small'</span>\n<span style=\"color: #FFFFFF\">console.log(strawberry.size); </span>\n<span style=\"color: #7CA668\">// output: small</span></code></pre>\n<h2 id=\"płytkie-kopie\">Płytkie kopie</h2>\n<p>Część funkcji dostarczonych <strong>natywnie</strong> przez JavaScript umożliwia <strong>płytkie skopiowanie</strong> obiektu. Dopóki zajmujemy się przestrzenią bez zagnieżdżeń, wszystko działa jak powinno. </p>\n<p><strong>Problem</strong> pojawia się, gdy <strong>modyfikujemy zagnieżdżone obiekty</strong> - wtedy nadal możemy <strong>modyfikować oryginał</strong>, co nie jest pożądane (dzięki rekurencyjnemu użyciu płytkich kopii możemy jednak stworzyć głęboką kopię, czym zajmiemy się później). </p>\n<p>Poniżej sposób na płytką kopię: </p>\n<h3 id=\"objectassign\">Object.assign()</h3>\n<pre class=\"shiki\" style=\"background-color: #000000\"><code><span style=\"color: #7CA668\">//Tworzy płytką kopię - klonuje właściwości najwyższego poziomu, pozostawiając referencję do zagnieżdzonych  </span>\n<span style=\"color: #569CD6\">var</span><span style=\"color: #FFFFFF\"> someOtherStrawberry </span><span style=\"color: #D4D4D4\">=</span><span style=\"color: #FFFFFF\"> Object.assign({}, strawberry);  </span>\n<span style=\"color: #FFFFFF\">someOtherStrawberry.size </span><span style=\"color: #D4D4D4\">=</span><span style=\"color: #FFFFFF\"> </span><span style=\"color: #CE9178\">'small'</span><span style=\"color: #FFFFFF\">;  </span>\n<span style=\"color: #FFFFFF\">console.log(strawberry.size) </span>\n<span style=\"color: #7CA668\">// output: large  </span>\n\n<span style=\"color: #FFFFFF\">someOtherStrawberry.shape.x </span><span style=\"color: #D4D4D4\">=</span><span style=\"color: #FFFFFF\"> </span><span style=\"color: #B5CEA8\">32</span><span style=\"color: #FFFFFF\">  </span>\n<span style=\"color: #FFFFFF\">console.log(strawberry.shape.x) </span>\n<span style=\"color: #7CA668\">// output: 32, wartość strawberry jest podmieniona przez modyfikacje na someOtherStrawberry!</span></code></pre>\n<h3 id=\"spread-operator-es6\">Spread operator ES6</h3>\n<p>Standard ES6 przynosi nam proste ułatwienia, pozwalające na dokonywanie kopii. Jednym z nich jest <strong>spread operator</strong> <code>...</code>, który <strong>płytko ignoruje</strong> wskaźnik do obiektu <strong>macierzystego</strong>. Dzięki temu otrzymujemy obiekty niezależne.</p>\n<pre class=\"shiki\" style=\"background-color: #000000\"><code><span style=\"color: #569CD6\">var</span><span style=\"color: #FFFFFF\"> strawberry </span><span style=\"color: #D4D4D4\">=</span><span style=\"color: #FFFFFF\"> {</span>\n<span style=\"color: #FFFFFF\">    color: </span><span style=\"color: #CE9178\">'red'</span><span style=\"color: #FFFFFF\">,</span>\n<span style=\"color: #FFFFFF\">    taste: </span><span style=\"color: #CE9178\">'sweet'</span><span style=\"color: #FFFFFF\">,</span>\n<span style=\"color: #FFFFFF\">    size: </span><span style=\"color: #CE9178\">'large'</span><span style=\"color: #FFFFFF\">,</span>\n<span style=\"color: #FFFFFF\">    shape: {</span>\n<span style=\"color: #FFFFFF\">        x: </span><span style=\"color: #B5CEA8\">10</span><span style=\"color: #FFFFFF\">,</span>\n<span style=\"color: #FFFFFF\">        y: </span><span style=\"color: #B5CEA8\">32</span><span style=\"color: #FFFFFF\">,</span>\n<span style=\"color: #FFFFFF\">        z: </span><span style=\"color: #B5CEA8\">33</span>\n<span style=\"color: #FFFFFF\">    }</span>\n<span style=\"color: #FFFFFF\">};</span>\n<span style=\"color: #569CD6\">const</span><span style=\"color: #FFFFFF\"> someOtherStrawberry </span><span style=\"color: #D4D4D4\">=</span><span style=\"color: #FFFFFF\"> {</span>\n<span style=\"color: #FFFFFF\">    </span><span style=\"color: #D4D4D4\">...</span><span style=\"color: #FFFFFF\">strawberry</span>\n<span style=\"color: #FFFFFF\">};</span>\n<span style=\"color: #FFFFFF\">someOtherStrawberry.size </span><span style=\"color: #D4D4D4\">=</span><span style=\"color: #FFFFFF\"> </span><span style=\"color: #CE9178\">'small'</span><span style=\"color: #FFFFFF\">;</span>\n<span style=\"color: #FFFFFF\">console.log(strawberry.size) </span>\n<span style=\"color: #7CA668\">// output: large, wszystko OK!  </span>\n\n<span style=\"color: #FFFFFF\">someOtherStrawberry.shape.x </span><span style=\"color: #D4D4D4\">=</span><span style=\"color: #FFFFFF\"> </span><span style=\"color: #B5CEA8\">32</span><span style=\"color: #FFFFFF\">;</span>\n<span style=\"color: #FFFFFF\">console.log(strawberry.shape.x) </span>\n<span style=\"color: #7CA668\">// output: 32, znowu podmienione przez modyfikacje na someOtherStrawberry :(</span></code></pre>\n<h2 id=\"sposoby-na-głęboką-kopię\">Sposoby na głęboką kopię</h2>\n<h3 id=\"jsonparse-jsonstringify\">JSON.parse(), JSON.stringify()</h3>\n<p>Kiedy tworzymy klona, chcielibyśmy by był całkowicie <strong>niezależny referencyjnie</strong> od oryginału, a jednocześnie był identyczny jak on. Łatwo można to uzyskać za pomocą niezbyt eleganckiej sztuczki z JSONem. Metoda ta działa tylko z <strong>strukturami danych</strong> - obiekt w tym wypadku nie może zawierać funkcji. </p>\n<p>Osobiście <strong>nie stosowałabym</strong> tego sposobu - w przypadku gdy przy wstępnych założeniach obiekt jest zwykłą strukturą danych, a później nieświadomy inny programista dopisze do niego metody, pojawi się nieoczekiwany i problematyczny bug.</p>\n<pre class=\"shiki\" style=\"background-color: #000000\"><code><span style=\"color: #569CD6\">var</span><span style=\"color: #FFFFFF\"> strawberry </span><span style=\"color: #D4D4D4\">=</span><span style=\"color: #FFFFFF\"> {</span>\n<span style=\"color: #FFFFFF\">    color: </span><span style=\"color: #CE9178\">'red'</span><span style=\"color: #FFFFFF\">,</span>\n<span style=\"color: #FFFFFF\">    taste: </span><span style=\"color: #CE9178\">'sweet'</span><span style=\"color: #FFFFFF\">,</span>\n<span style=\"color: #FFFFFF\">    size: </span><span style=\"color: #CE9178\">'large'</span><span style=\"color: #FFFFFF\">,</span>\n<span style=\"color: #FFFFFF\">    shape: {</span>\n<span style=\"color: #FFFFFF\">        x: </span><span style=\"color: #B5CEA8\">10</span><span style=\"color: #FFFFFF\">,</span>\n<span style=\"color: #FFFFFF\">        y: </span><span style=\"color: #B5CEA8\">32</span><span style=\"color: #FFFFFF\">,</span>\n<span style=\"color: #FFFFFF\">        z: </span><span style=\"color: #B5CEA8\">33</span>\n<span style=\"color: #FFFFFF\">    }</span>\n<span style=\"color: #FFFFFF\">};</span>\n<span style=\"color: #569CD6\">const</span><span style=\"color: #FFFFFF\"> someOtherStrawberry </span><span style=\"color: #D4D4D4\">=</span><span style=\"color: #FFFFFF\"> JSON.parse(JSON.stringify(strawberry));</span>\n<span style=\"color: #FFFFFF\">someOtherStrawberry.size </span><span style=\"color: #D4D4D4\">=</span><span style=\"color: #FFFFFF\"> </span><span style=\"color: #CE9178\">'small'</span><span style=\"color: #FFFFFF\">;</span>\n<span style=\"color: #FFFFFF\">console.log(strawberry.size) </span>\n<span style=\"color: #7CA668\">// output: large, wszystko OK!  </span>\n\n<span style=\"color: #FFFFFF\">someOtherStrawberry.shape.x </span><span style=\"color: #D4D4D4\">=</span><span style=\"color: #FFFFFF\"> </span><span style=\"color: #B5CEA8\">32</span><span style=\"color: #FFFFFF\">;</span>\n<span style=\"color: #FFFFFF\">console.log(strawberry.shape.x) </span>\n<span style=\"color: #7CA668\">// output: 10, wszystko OK!</span></code></pre>\n<h3 id=\"customowa-funkcja-do-głębokiego-kopiowania\">Customowa funkcja do głębokiego kopiowania</h3>\n<p>Posiadamy już narzędzia do tworzenia płytkich kopii, możemy więc je wykorzystać przy tworzeniu głębokich kopii, wystarczy <strong>rekurencyjnie</strong> przejść po wszystkich <strong>węzłach</strong>. </p>\n<p>Algorytm sprawdza czy przekazana w argumencie wartość - jeśli jest <strong>prymitywem</strong>, po prostu zwraca go. W przypadku, gdy argument jest <strong>obiektem</strong>, przechodzimy po <strong>każdym</strong> jego <strong>polu</strong> i sprawdzamy czy jest ono typem <strong>prymitywnym</strong>, jeśli nie - wywołujemy funkcję \"rozbijającą\" dla pola nie-prymitywnego .</p>\n<p>Wszystko się powtarza do momentu, gdy algorytm przejdzie po całym <strong>drzewie</strong>.</p>\n<pre class=\"shiki\" style=\"background-color: #000000\"><code><span style=\"color: #569CD6\">const</span><span style=\"color: #FFFFFF\"> deepCopyFunc </span><span style=\"color: #D4D4D4\">=</span><span style=\"color: #FFFFFF\"> child </span><span style=\"color: #569CD6\">=&gt;</span><span style=\"color: #FFFFFF\"> {</span>\n<span style=\"color: #FFFFFF\">    </span><span style=\"color: #569CD6\">let</span><span style=\"color: #FFFFFF\"> parent, value, key</span>\n<span style=\"color: #FFFFFF\">    </span><span style=\"color: #569CD6\">if</span><span style=\"color: #FFFFFF\"> (</span><span style=\"color: #569CD6\">typeof</span><span style=\"color: #FFFFFF\"> child </span><span style=\"color: #D4D4D4\">!==</span><span style=\"color: #FFFFFF\"> </span><span style=\"color: #CE9178\">\"object\"</span><span style=\"color: #FFFFFF\"> </span><span style=\"color: #D4D4D4\">||</span><span style=\"color: #FFFFFF\"> child </span><span style=\"color: #D4D4D4\">===</span><span style=\"color: #FFFFFF\"> </span><span style=\"color: #569CD6\">null</span><span style=\"color: #FFFFFF\">) {</span>\n<span style=\"color: #FFFFFF\">        </span><span style=\"color: #569CD6\">return</span><span style=\"color: #FFFFFF\"> child </span><span style=\"color: #7CA668\">// zwracamy jeśli jest typem prymitywnym  </span>\n<span style=\"color: #FFFFFF\">    }</span>\n<span style=\"color: #FFFFFF\">    parent </span><span style=\"color: #D4D4D4\">=</span><span style=\"color: #FFFFFF\"> Array.isArray(child) </span><span style=\"color: #D4D4D4\">?</span><span style=\"color: #FFFFFF\"> [] </span><span style=\"color: #D4D4D4\">:</span><span style=\"color: #FFFFFF\"> {}</span>\n\n<span style=\"color: #FFFFFF\">    </span><span style=\"color: #7CA668\">//jeśli jest obiektem to iterujemy po każdym property  </span>\n<span style=\"color: #FFFFFF\">    </span><span style=\"color: #569CD6\">for</span><span style=\"color: #FFFFFF\"> (key </span><span style=\"color: #569CD6\">in</span><span style=\"color: #FFFFFF\"> child) {</span>\n<span style=\"color: #FFFFFF\">        value </span><span style=\"color: #D4D4D4\">=</span><span style=\"color: #FFFFFF\"> child[key]</span>\n<span style=\"color: #FFFFFF\">        </span><span style=\"color: #7CA668\">//jeśli wartość dla key jest obiektem to wykonujemy rekurencyjną kopie  </span>\n<span style=\"color: #FFFFFF\">        </span><span style=\"color: #569CD6\">if</span><span style=\"color: #FFFFFF\"> (value </span><span style=\"color: #D4D4D4\">!==</span><span style=\"color: #FFFFFF\"> </span><span style=\"color: #569CD6\">null</span><span style=\"color: #FFFFFF\"> </span><span style=\"color: #D4D4D4\">&&</span><span style=\"color: #FFFFFF\"> </span><span style=\"color: #569CD6\">typeof</span><span style=\"color: #FFFFFF\"> value </span><span style=\"color: #D4D4D4\">===</span><span style=\"color: #FFFFFF\"> </span><span style=\"color: #CE9178\">\"object\"</span><span style=\"color: #FFFFFF\">) {</span>\n<span style=\"color: #FFFFFF\">            parent[key] </span><span style=\"color: #D4D4D4\">=</span><span style=\"color: #FFFFFF\"> deepCopyFunc(value)</span>\n<span style=\"color: #FFFFFF\">        } </span><span style=\"color: #569CD6\">else</span><span style=\"color: #FFFFFF\"> {</span>\n<span style=\"color: #FFFFFF\">            parent[key] </span><span style=\"color: #D4D4D4\">=</span><span style=\"color: #FFFFFF\"> value</span>\n<span style=\"color: #FFFFFF\">        }</span>\n<span style=\"color: #FFFFFF\">    }</span>\n<span style=\"color: #FFFFFF\">    </span><span style=\"color: #569CD6\">return</span><span style=\"color: #FFFFFF\"> parent</span>\n<span style=\"color: #FFFFFF\">}</span>\n\n<span style=\"color: #569CD6\">let</span><span style=\"color: #FFFFFF\"> originalArray </span><span style=\"color: #D4D4D4\">=</span><span style=\"color: #FFFFFF\"> [</span><span style=\"color: #B5CEA8\">37</span><span style=\"color: #FFFFFF\">, </span><span style=\"color: #B5CEA8\">3700</span><span style=\"color: #FFFFFF\">, {</span>\n<span style=\"color: #FFFFFF\">    hello: </span><span style=\"color: #CE9178\">\"world\"</span>\n<span style=\"color: #FFFFFF\">}]</span></code></pre>\n<p>Myślę, że artykuł okazał się pomocny, a moje objaśnienia niezbyt trudne. Jeśli zauważysz gdzieś błąd, proszę, napisz do mnie. Zależy mi, by mój blog był rzetelnym źródłem informacji, więc z chęcią przyjmuję krytykę.</p>\n","description":"W tym poście opisuję metody klonowania obiektów w javascript - w języku, w którym ich zachowanie jest całkiem nietypowe i nieoczekiwane.","timeToRead":4,"cover":"/images/posts/kopie/cover.jpg","author":{"id":"Julia Glaszka","title":"Julia Glaszka"},"tags":[{"id":"javascript","title":"javascript","path":"/tag/javascript/"},{"id":"inżynieria","title":"inżynieria","path":"/tag/in%C5%BCynieria/"}]},"recommendedposts":{"edges":[{"node":{"id":"5c6912511fbf00580160f309c8bff279","title":"Obiektywizm a rozwój w IT","path":"/obiektywizm-a-rozwoj-w-it/","cover":"/images/posts/obiektywizm/atlas.jpg"}},{"node":{"id":"507900b37c02db543d8fa26f4705fb1e","title":"Wykorzystaj cały potencjał klastra MongoDB z pomocą preferencji odczytu","path":"/wykorzystaj-caly-potencjal-klastra-mongo-db-z-pomoca-preferencji-odczytu/","cover":"/images/posts/mongodb-read-preferences/route.jpg"}},{"node":{"id":"c854d4a554f3e6aa74a421fac8beb243","title":"Konfiguracja ClusterSettings w MongoDB Java Driver","path":"/konfiguracja-cluster-settings-w-mongo-db-java-driver/","cover":"/images/posts/cluster-settings-mongo/adjusting.jpg"}}]}},"context":{}}