{"hash":"d33f7f3abd897bc488323552c61cecc69d4cb3d2","data":{"tag":{"id":"programowanie","title":"programowanie","path":"/tag/programowanie/","belongsTo":{"totalCount":2,"pageInfo":{"totalPages":1,"currentPage":1},"edges":[{"node":{"id":"888e79f6459f76d95ede4741ee5f58ca","title":"Prawo Demeter - zasada ograniczenia interakcji","datetime":"2020-04-30 15:56:24","path":"/prawo-demeter-zasada-ograniczenia-interakcji/","content":"<p>Przy projektowaniu obiektowym możemy się zastanowić, w jaki sposób uprościć relacje między naszymi obiektami, tak aby zmiana w jednej klasie nie propagowała konieczności zmian w wielu innych.\nZ pomocą przychodzi nam <a href=\"https://pl.wikipedia.org/wiki/Prawo_Demeter\" title=\"**prawo Demeter,** \" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><strong>prawo Demeter,</strong> </a>które w skrócie ogranicza nas do interakcji jedynie z najbliższymi sąsiednimi obiektami. Dzięki temu, nasz obiekt jest zależny tylko od swoich sąsiadów. Kiedy implementacja sąsiada naszego sąsiada się zmieni - nie interesuje nas to. Jest to tak zwany luźny związek (<em>ang. loose coupling</em>).\nNie łamiemy w ten sposób zasady enkapsulacji obiektu i nie tworzymy dużej ilości powodów, dla których mielibyśmy modyfikować naszą klasę. W ten sposób możemy sprawić, że nasz projekt jest zgodny z zasadami <a href=\"https://pl.wikipedia.org/wiki/SOLID_(programowanie_obiektowe)\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">SOLID</a>.\nPoniżej, na przykładzie logiki aplikacji quizowej, możemy przeanalizować przypadek <strong>tight coupled</strong> (1) i<strong> loose coupled</strong> (2). </p>\n<pre class=\"shiki\" style=\"background-color: #000c18\"><code><span style=\"color: #223355\">//// przykład tight coupling (1)</span>\n<span style=\"color: #9966B8\">class</span><span style=\"color: #6688CC\"> </span><span style=\"color: #FFEEBB\">QuizWhichBreaksLawOfDemeter</span><span style=\"color: #6688CC\"> {</span>\n<span style=\"color: #6688CC\">    </span><span style=\"color: #225588\">private</span><span style=\"color: #6688CC\"> questions</span><span style=\"color: #225588\">:</span><span style=\"color: #6688CC\"> </span><span style=\"color: #FFEEBB\">Question</span><span style=\"color: #6688CC\">[]</span>\n<span style=\"color: #6688CC\">    </span><span style=\"color: #223355\">// ...</span>\n<span style=\"color: #6688CC\">    </span><span style=\"color: #DDBB88\">isAnswerCorrect</span><span style=\"color: #6688CC\">(</span><span style=\"color: #2277FF\">question</span><span style=\"color: #225588\">:</span><span style=\"color: #6688CC\"> </span><span style=\"color: #FFEEBB\">Question</span><span style=\"color: #6688CC\">) {</span>\n<span style=\"color: #6688CC\">     </span><span style=\"color: #223355\">// poniżej łamiemy Prawo Demeter</span>\n<span style=\"color: #6688CC\">     </span><span style=\"color: #223355\">// wnikając w implementację answer</span>\n<span style=\"color: #6688CC\">      </span><span style=\"color: #225588\">return</span><span style=\"color: #6688CC\"> question.</span><span style=\"color: #DDBB88\">getAnswer</span><span style=\"color: #6688CC\">().</span><span style=\"color: #DDBB88\">getId</span><span style=\"color: #6688CC\">() </span><span style=\"color: #225588\">==</span><span style=\"color: #6688CC\"> </span>\n<span style=\"color: #6688CC\">      question.</span><span style=\"color: #DDBB88\">getUserAnswer</span><span style=\"color: #6688CC\">().</span><span style=\"color: #DDBB88\">getId</span><span style=\"color: #6688CC\">()</span>\n<span style=\"color: #6688CC\">    } </span>\n<span style=\"color: #6688CC\">  </span>\n<span style=\"color: #6688CC\">    </span><span style=\"color: #DDBB88\">countCorrectAnswers</span><span style=\"color: #6688CC\">()</span><span style=\"color: #225588\">:</span><span style=\"color: #6688CC\"> </span><span style=\"color: #9966B8\">number</span><span style=\"color: #6688CC\"> {</span>\n<span style=\"color: #6688CC\">      </span><span style=\"color: #225588\">return</span><span style=\"color: #6688CC\"> this.questions</span>\n<span style=\"color: #6688CC\">        .</span><span style=\"color: #DDBB88\">filter</span><span style=\"color: #6688CC\">(</span><span style=\"color: #2277FF\">q</span><span style=\"color: #6688CC\"> </span><span style=\"color: #9966B8\">=&gt;</span><span style=\"color: #6688CC\"> this.</span><span style=\"color: #DDBB88\">isAnswerCorrect</span><span style=\"color: #6688CC\">(q))</span>\n<span style=\"color: #6688CC\">        .length</span>\n<span style=\"color: #6688CC\">    }</span>\n<span style=\"color: #6688CC\">  } </span>\n\n<span style=\"color: #223355\">// anemiczna klasa question, nic prócz getterów i setterów</span>\n<span style=\"color: #6688CC\"> </span><span style=\"color: #9966B8\">class</span><span style=\"color: #6688CC\"> </span><span style=\"color: #FFEEBB\">Question</span><span style=\"color: #6688CC\"> {</span>\n<span style=\"color: #6688CC\">    </span><span style=\"color: #225588\">private</span><span style=\"color: #6688CC\"> answer</span><span style=\"color: #225588\">:</span><span style=\"color: #6688CC\"> </span><span style=\"color: #FFEEBB\">QuizOption</span>\n<span style=\"color: #6688CC\">    </span><span style=\"color: #225588\">private</span><span style=\"color: #6688CC\"> userAnswer</span><span style=\"color: #225588\">:</span><span style=\"color: #6688CC\"> </span><span style=\"color: #FFEEBB\">QuizOption</span>\n<span style=\"color: #6688CC\">    </span><span style=\"color: #223355\">// ...</span>\n<span style=\"color: #6688CC\">    </span><span style=\"color: #DDBB88\">getUserAnswer</span><span style=\"color: #6688CC\">()</span><span style=\"color: #225588\">:</span><span style=\"color: #6688CC\"> </span><span style=\"color: #FFEEBB\">QuizOption</span><span style=\"color: #6688CC\"> {</span>\n<span style=\"color: #6688CC\">        </span><span style=\"color: #225588\">return</span><span style=\"color: #6688CC\"> this.userAnswer</span>\n<span style=\"color: #6688CC\">    }</span>\n<span style=\"color: #6688CC\">    </span><span style=\"color: #DDBB88\">getAnswer</span><span style=\"color: #6688CC\">()</span><span style=\"color: #225588\">:</span><span style=\"color: #6688CC\"> </span><span style=\"color: #FFEEBB\">QuizOption</span><span style=\"color: #6688CC\"> {</span>\n<span style=\"color: #6688CC\">        </span><span style=\"color: #225588\">return</span><span style=\"color: #6688CC\"> this.answer</span>\n<span style=\"color: #6688CC\">    }</span>\n<span style=\"color: #6688CC\">  } </span></code></pre>\n<p>W powyższym przykładzie z poziomu quizu dostajemy się do wnętrza answer, który nie jest naszym bezpośrednim sąsiadem (quiz &#x3C;-> question &#x3C;-> answer). Metoda <code>isAnswerCorrect()</code> wywołuje łańcuch <code>question.getUserAnswer().getId()</code>, dostając się głęboko do struktury, której szczegółów implementacyjnych nie powinniśmy znać. Łamiemy Prawo Demeter. </p>\n<p>Zastanówmy się, jak możemy rozwiązać ten problem. Musimy ograniczyć splątanie naszych klas i ich wspólną zależność od siebie.\nPoniżej przykład, który jest nieco lepszy. Metoda <code>isAnswerCorrect()</code> została przeniesiona z klasy Quiz, do klasy Question. Manipuluje ona już swoimi własnymi sąsiadami, wystawiając Quizowi tylko metodę do sprawdzenia ( <code>isAnswerCorrect()</code> ).</p>\n<pre class=\"shiki\" style=\"background-color: #000c18\"><code><span style=\"color: #223355\">// przykład loose coupling (2)</span>\n<span style=\"color: #9966B8\">class</span><span style=\"color: #6688CC\"> </span><span style=\"color: #FFEEBB\">QuizLooseCoupled</span><span style=\"color: #6688CC\"> {</span>\n<span style=\"color: #6688CC\">    questions</span><span style=\"color: #225588\">:</span><span style=\"color: #6688CC\"> </span><span style=\"color: #FFEEBB\">Question</span><span style=\"color: #6688CC\">[]</span>\n<span style=\"color: #6688CC\">\t</span><span style=\"color: #223355\">// nie interesuje nas jak jest sprawdzana odpowiedź</span>\n<span style=\"color: #6688CC\">\t</span><span style=\"color: #223355\">// po prostu wywołujemy metodę naszego sąsiedniego obiektu</span>\n<span style=\"color: #6688CC\">     </span><span style=\"color: #DDBB88\">countCorrectAnswers</span><span style=\"color: #6688CC\">()</span><span style=\"color: #225588\">:</span><span style=\"color: #6688CC\"> </span><span style=\"color: #9966B8\">number</span><span style=\"color: #6688CC\"> {</span>\n<span style=\"color: #6688CC\">      </span><span style=\"color: #225588\">return</span><span style=\"color: #6688CC\"> this.questions</span>\n<span style=\"color: #6688CC\">        .</span><span style=\"color: #DDBB88\">filter</span><span style=\"color: #6688CC\">(</span><span style=\"color: #2277FF\">q</span><span style=\"color: #6688CC\"> </span><span style=\"color: #9966B8\">=&gt;</span><span style=\"color: #6688CC\"> q.</span><span style=\"color: #DDBB88\">isAnswerCorrect</span><span style=\"color: #6688CC\">())</span>\n<span style=\"color: #6688CC\">        .length</span>\n<span style=\"color: #6688CC\">    }</span>\n<span style=\"color: #6688CC\">  }</span>\n\n<span style=\"color: #6688CC\">  </span><span style=\"color: #9966B8\">class</span><span style=\"color: #6688CC\"> </span><span style=\"color: #FFEEBB\">Question</span><span style=\"color: #6688CC\"> {</span>\n<span style=\"color: #6688CC\">    </span><span style=\"color: #223355\">// ...</span>\n<span style=\"color: #6688CC\">    </span><span style=\"color: #225588\">private</span><span style=\"color: #6688CC\"> answer</span><span style=\"color: #225588\">:</span><span style=\"color: #6688CC\"> </span><span style=\"color: #FFEEBB\">QuizOption</span>\n<span style=\"color: #6688CC\">    </span><span style=\"color: #225588\">private</span><span style=\"color: #6688CC\"> userAnswer</span><span style=\"color: #225588\">:</span><span style=\"color: #6688CC\"> </span><span style=\"color: #FFEEBB\">QuizOption</span>\n<span style=\"color: #6688CC\">    </span><span style=\"color: #223355\">// tutaj przeniesiona jest odpowiedzialność funkcji</span>\n<span style=\"color: #6688CC\">    </span><span style=\"color: #DDBB88\">isAnswerCorrect</span><span style=\"color: #6688CC\">() {</span>\n<span style=\"color: #6688CC\">      </span><span style=\"color: #225588\">return</span><span style=\"color: #6688CC\"> this.answer.</span><span style=\"color: #DDBB88\">getId</span><span style=\"color: #6688CC\">() </span><span style=\"color: #225588\">===</span><span style=\"color: #6688CC\"> this.userAnswer.</span><span style=\"color: #DDBB88\">getId</span><span style=\"color: #6688CC\">()</span>\n<span style=\"color: #6688CC\">    } </span>\n<span style=\"color: #6688CC\">  } </span></code></pre>\n<p>Podany przykład jest prosty. Popełnienie błędu z pierwszej sekcji nie jest fatalne w skutkach, refaktoryzacja zajmie pół minuty. W przypadku większych aplikacji z wieloma tight coupled obiektami może powstać problem, który poskutkuje efektem domina - naprawiając jeden obiekt, musimy naprawić 2,3,4 następnych…</p>\n<p>Na ile posiadamy czasu, warto zastanowić się nad rozluznieniem wiezi naszych obiektów póki nie ma dramatu - nie żyjemy w starożytnej Grecji, ale Prawo Demeter warto znać :) </p>\n<p>Całość kodu można znaleźć na moim <a href=\"https://github.com/julia-glaszka/law-of-demeter\" title=\"githubie\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">githubie</a>.</p>\n","excerpt":"Przy projektowaniu obiektowym możemy się zastanowić, w jaki sposób uprościć relacje między naszymi obiektami, tak aby zmiana w jednej klasie nie propagowała konieczności zmian w wielu innych. Z","description":"Krótka notatka o prawie demeter z przykładami","cover":"/images/posts/prawo-demeter/cover.jpg","timeToRead":2,"author":{"id":"Julia Glaszka","title":"Julia Glaszka"}}},{"node":{"id":"e8c9d1ee5f11bad9b7871e8cff0f2f63","title":"Wykonywanie kopii obiektów w JavaScript","datetime":"2020-03-01 14:43:24","path":"/wykonywanie-kopii-obiektow-w-java-script/","content":"<p><strong>Kopiowanie</strong> to mechanizm tworzenia <strong>duplikatów</strong>. W przypadku <strong>prymitywów</strong> (string, number, boolean itd) sprawa jest prosta, możemy spokojnie wykonywać wszystkie operacje bez obaw o nadpisywanie oryginału. </p>\n<p>Sprawa się komplikuje przy zastosowaniu przypisania obiektu za pomocą prostego = - wtedy tworzy się <strong>referencja</strong> do oryginału. Kopia jest zależna od oryginału, więc każda modyfikacja w obiekcie oddziałuje na resztę obiektów. Czasami taki efekt nie jest pożądany, niestety w js brakuje natywnych, prostych sposobów na klonowanie obiektów bez tworzenia referencji (wskaźnika na oryginał), trzeba w tym celu wykorzystywać różne hacki. </p>\n<p>W tym artykule omówię część z nich, mam nadzieję że komuś się przydadzą.</p>\n<h2 id=\"trochę-teorii\">Trochę teorii</h2>\n<p>Istnieją rodzaje kopiowania obiektów w js:</p>\n<ul>\n<li><strong>Brak</strong> - <strong>referencja</strong>, wskazuje na adres obiektu macierzystego. Przy podmianie jakiejkolwiek wartości obiektu, zamieniają się one równocześnie w kopii i oryginale. Kopia jest <strong>silnie zależna</strong> od oryginału.</li>\n<li><strong>Płytkie (shallow)</strong> - otrzymujemy prostą kopię, która posiada <strong>jednopoziomową kopię</strong>, głębsze zagnieżdzenia są <strong>referencją do oryginału</strong> i przy podmianie wartości zmieni się również w innych obiektach.</li>\n<li><strong>Głębokie (deep)</strong> - kopie są <strong>identyczne</strong> i <strong>niezależne</strong> od siebie. Obiekt jest <strong>autonomiczny</strong>, posiada wartości na własność, <strong>nic nie współdzieli</strong> - zmiana w oryginale nie zmodyfikuje kopii.</li>\n</ul>\n<h2 id=\"brak-kopii\">Brak kopii</h2>\n<p>Zacznijmy od tego, w jaki sposób nie skopiujemy obiektu, a który jednak początkowo wydaje się słusznym i prostym rozwiązaniem. Jak widać, przy podmianie wartości w klonie, wartość oryginału również się zmieniła, co nie jest oczekiwanym efektem.</p>\n<pre class=\"shiki\" style=\"background-color: #000c18\"><code><span style=\"color: #223355\">// proste przypisanie  </span>\n<span style=\"color: #9966B8\">var</span><span style=\"color: #6688CC\"> strawberry </span><span style=\"color: #225588\">=</span><span style=\"color: #6688CC\"> {</span>\n<span style=\"color: #6688CC\">    color: </span><span style=\"color: #22AA44\">'red'</span><span style=\"color: #6688CC\">,</span>\n<span style=\"color: #6688CC\">    taste: </span><span style=\"color: #22AA44\">'sweet'</span><span style=\"color: #6688CC\">,</span>\n<span style=\"color: #6688CC\">    size: </span><span style=\"color: #22AA44\">'large'</span><span style=\"color: #6688CC\">,</span>\n<span style=\"color: #6688CC\">    shape: {</span>\n<span style=\"color: #6688CC\">        x: </span><span style=\"color: #F280D0\">10</span><span style=\"color: #6688CC\">,</span>\n<span style=\"color: #6688CC\">        y: </span><span style=\"color: #F280D0\">32</span><span style=\"color: #6688CC\">,</span>\n<span style=\"color: #6688CC\">        z: </span><span style=\"color: #F280D0\">33</span>\n<span style=\"color: #6688CC\">    }</span>\n<span style=\"color: #6688CC\">};</span>\n\n<span style=\"color: #9966B8\">var</span><span style=\"color: #6688CC\"> someOtherStrawberry </span><span style=\"color: #225588\">=</span><span style=\"color: #6688CC\"> strawberry;</span>\n<span style=\"color: #6688CC\">someOtherStrawberry.size </span><span style=\"color: #225588\">=</span><span style=\"color: #6688CC\"> </span><span style=\"color: #22AA44\">'small'</span>\n<span style=\"color: #9966B8\">console</span><span style=\"color: #6688CC\">.</span><span style=\"color: #9966B8\">log</span><span style=\"color: #6688CC\">(strawberry.size); </span>\n<span style=\"color: #223355\">// output: small</span></code></pre>\n<h2 id=\"płytkie-kopie\">Płytkie kopie</h2>\n<p>Część funkcji dostarczonych <strong>natywnie</strong> przez JavaScript umożliwia <strong>płytkie skopiowanie</strong> obiektu. Dopóki zajmujemy się przestrzenią bez zagnieżdżeń, wszystko działa jak powinno. </p>\n<p><strong>Problem</strong> pojawia się, gdy <strong>modyfikujemy zagnieżdżone obiekty</strong> - wtedy nadal możemy <strong>modyfikować oryginał</strong>, co nie jest pożądane (dzięki rekurencyjnemu użyciu płytkich kopii możemy jednak stworzyć głęboką kopię, czym zajmiemy się później). </p>\n<p>Poniżej sposób na płytką kopię: </p>\n<h3 id=\"objectassign\">Object.assign()</h3>\n<pre class=\"shiki\" style=\"background-color: #000c18\"><code><span style=\"color: #223355\">//Tworzy płytką kopię - klonuje właściwości najwyższego poziomu, pozostawiając referencję do zagnieżdzonych  </span>\n<span style=\"color: #9966B8\">var</span><span style=\"color: #6688CC\"> someOtherStrawberry </span><span style=\"color: #225588\">=</span><span style=\"color: #6688CC\"> </span><span style=\"color: #9966B8\">Object</span><span style=\"color: #6688CC\">.</span><span style=\"color: #DDBB88\">assign</span><span style=\"color: #6688CC\">({}, strawberry);  </span>\n<span style=\"color: #6688CC\">someOtherStrawberry.size </span><span style=\"color: #225588\">=</span><span style=\"color: #6688CC\"> </span><span style=\"color: #22AA44\">'small'</span><span style=\"color: #6688CC\">;  </span>\n<span style=\"color: #9966B8\">console</span><span style=\"color: #6688CC\">.</span><span style=\"color: #9966B8\">log</span><span style=\"color: #6688CC\">(strawberry.size) </span>\n<span style=\"color: #223355\">// output: large  </span>\n\n<span style=\"color: #6688CC\">someOtherStrawberry.shape.x </span><span style=\"color: #225588\">=</span><span style=\"color: #6688CC\"> </span><span style=\"color: #F280D0\">32</span><span style=\"color: #6688CC\">  </span>\n<span style=\"color: #9966B8\">console</span><span style=\"color: #6688CC\">.</span><span style=\"color: #9966B8\">log</span><span style=\"color: #6688CC\">(strawberry.shape.x) </span>\n<span style=\"color: #223355\">// output: 32, wartość strawberry jest podmieniona przez modyfikacje na someOtherStrawberry!</span></code></pre>\n<h3 id=\"spread-operator-es6\">Spread operator ES6</h3>\n<p>Standard ES6 przynosi nam proste ułatwienia, pozwalające na dokonywanie kopii. Jednym z nich jest <strong>spread operator</strong> <code>...</code>, który <strong>płytko ignoruje</strong> wskaźnik do obiektu <strong>macierzystego</strong>. Dzięki temu otrzymujemy obiekty niezależne.</p>\n<pre class=\"shiki\" style=\"background-color: #000c18\"><code><span style=\"color: #9966B8\">var</span><span style=\"color: #6688CC\"> strawberry </span><span style=\"color: #225588\">=</span><span style=\"color: #6688CC\"> {</span>\n<span style=\"color: #6688CC\">    color: </span><span style=\"color: #22AA44\">'red'</span><span style=\"color: #6688CC\">,</span>\n<span style=\"color: #6688CC\">    taste: </span><span style=\"color: #22AA44\">'sweet'</span><span style=\"color: #6688CC\">,</span>\n<span style=\"color: #6688CC\">    size: </span><span style=\"color: #22AA44\">'large'</span><span style=\"color: #6688CC\">,</span>\n<span style=\"color: #6688CC\">    shape: {</span>\n<span style=\"color: #6688CC\">        x: </span><span style=\"color: #F280D0\">10</span><span style=\"color: #6688CC\">,</span>\n<span style=\"color: #6688CC\">        y: </span><span style=\"color: #F280D0\">32</span><span style=\"color: #6688CC\">,</span>\n<span style=\"color: #6688CC\">        z: </span><span style=\"color: #F280D0\">33</span>\n<span style=\"color: #6688CC\">    }</span>\n<span style=\"color: #6688CC\">};</span>\n<span style=\"color: #9966B8\">const</span><span style=\"color: #6688CC\"> someOtherStrawberry </span><span style=\"color: #225588\">=</span><span style=\"color: #6688CC\"> {</span>\n<span style=\"color: #6688CC\">    </span><span style=\"color: #225588\">...</span><span style=\"color: #6688CC\">strawberry</span>\n<span style=\"color: #6688CC\">};</span>\n<span style=\"color: #6688CC\">someOtherStrawberry.size </span><span style=\"color: #225588\">=</span><span style=\"color: #6688CC\"> </span><span style=\"color: #22AA44\">'small'</span><span style=\"color: #6688CC\">;</span>\n<span style=\"color: #9966B8\">console</span><span style=\"color: #6688CC\">.</span><span style=\"color: #9966B8\">log</span><span style=\"color: #6688CC\">(strawberry.size) </span>\n<span style=\"color: #223355\">// output: large, wszystko OK!  </span>\n\n<span style=\"color: #6688CC\">someOtherStrawberry.shape.x </span><span style=\"color: #225588\">=</span><span style=\"color: #6688CC\"> </span><span style=\"color: #F280D0\">32</span><span style=\"color: #6688CC\">;</span>\n<span style=\"color: #9966B8\">console</span><span style=\"color: #6688CC\">.</span><span style=\"color: #9966B8\">log</span><span style=\"color: #6688CC\">(strawberry.shape.x) </span>\n<span style=\"color: #223355\">// output: 32, znowu podmienione przez modyfikacje na someOtherStrawberry :(</span></code></pre>\n<h2 id=\"sposoby-na-głęboką-kopię\">Sposoby na głęboką kopię</h2>\n<h3 id=\"jsonparse-jsonstringify\">JSON.parse(), JSON.stringify()</h3>\n<p>Kiedy tworzymy klona, chcielibyśmy by był całkowicie <strong>niezależny referencyjnie</strong> od oryginału, a jednocześnie był identyczny jak on. Łatwo można to uzyskać za pomocą niezbyt eleganckiej sztuczki z JSONem. Metoda ta działa tylko z <strong>strukturami danych</strong> - obiekt w tym wypadku nie może zawierać funkcji. </p>\n<p>Osobiście <strong>nie stosowałabym</strong> tego sposobu - w przypadku gdy przy wstępnych założeniach obiekt jest zwykłą strukturą danych, a później nieświadomy inny programista dopisze do niego metody, pojawi się nieoczekiwany i problematyczny bug.</p>\n<pre class=\"shiki\" style=\"background-color: #000c18\"><code><span style=\"color: #9966B8\">var</span><span style=\"color: #6688CC\"> strawberry </span><span style=\"color: #225588\">=</span><span style=\"color: #6688CC\"> {</span>\n<span style=\"color: #6688CC\">    color: </span><span style=\"color: #22AA44\">'red'</span><span style=\"color: #6688CC\">,</span>\n<span style=\"color: #6688CC\">    taste: </span><span style=\"color: #22AA44\">'sweet'</span><span style=\"color: #6688CC\">,</span>\n<span style=\"color: #6688CC\">    size: </span><span style=\"color: #22AA44\">'large'</span><span style=\"color: #6688CC\">,</span>\n<span style=\"color: #6688CC\">    shape: {</span>\n<span style=\"color: #6688CC\">        x: </span><span style=\"color: #F280D0\">10</span><span style=\"color: #6688CC\">,</span>\n<span style=\"color: #6688CC\">        y: </span><span style=\"color: #F280D0\">32</span><span style=\"color: #6688CC\">,</span>\n<span style=\"color: #6688CC\">        z: </span><span style=\"color: #F280D0\">33</span>\n<span style=\"color: #6688CC\">    }</span>\n<span style=\"color: #6688CC\">};</span>\n<span style=\"color: #9966B8\">const</span><span style=\"color: #6688CC\"> someOtherStrawberry </span><span style=\"color: #225588\">=</span><span style=\"color: #6688CC\"> </span><span style=\"color: #9966B8\">JSON</span><span style=\"color: #6688CC\">.</span><span style=\"color: #9966B8\">parse</span><span style=\"color: #6688CC\">(</span><span style=\"color: #9966B8\">JSON</span><span style=\"color: #6688CC\">.</span><span style=\"color: #9966B8\">stringify</span><span style=\"color: #6688CC\">(strawberry));</span>\n<span style=\"color: #6688CC\">someOtherStrawberry.size </span><span style=\"color: #225588\">=</span><span style=\"color: #6688CC\"> </span><span style=\"color: #22AA44\">'small'</span><span style=\"color: #6688CC\">;</span>\n<span style=\"color: #9966B8\">console</span><span style=\"color: #6688CC\">.</span><span style=\"color: #9966B8\">log</span><span style=\"color: #6688CC\">(strawberry.size) </span>\n<span style=\"color: #223355\">// output: large, wszystko OK!  </span>\n\n<span style=\"color: #6688CC\">someOtherStrawberry.shape.x </span><span style=\"color: #225588\">=</span><span style=\"color: #6688CC\"> </span><span style=\"color: #F280D0\">32</span><span style=\"color: #6688CC\">;</span>\n<span style=\"color: #9966B8\">console</span><span style=\"color: #6688CC\">.</span><span style=\"color: #9966B8\">log</span><span style=\"color: #6688CC\">(strawberry.shape.x) </span>\n<span style=\"color: #223355\">// output: 10, wszystko OK!</span></code></pre>\n<h3 id=\"customowa-funkcja-do-głębokiego-kopiowania\">Customowa funkcja do głębokiego kopiowania</h3>\n<p>Posiadamy już narzędzia do tworzenia płytkich kopii, możemy więc je wykorzystać przy tworzeniu głębokich kopii, wystarczy <strong>rekurencyjnie</strong> przejść po wszystkich <strong>węzłach</strong>. </p>\n<p>Algorytm sprawdza czy przekazana w argumencie wartość - jeśli jest <strong>prymitywem</strong>, po prostu zwraca go. W przypadku, gdy argument jest <strong>obiektem</strong>, przechodzimy po <strong>każdym</strong> jego <strong>polu</strong> i sprawdzamy czy jest ono typem <strong>prymitywnym</strong>, jeśli nie - wywołujemy funkcję \"rozbijającą\" dla pola nie-prymitywnego .</p>\n<p>Wszystko się powtarza do momentu, gdy algorytm przejdzie po całym <strong>drzewie</strong>.</p>\n<pre class=\"shiki\" style=\"background-color: #000c18\"><code><span style=\"color: #9966B8\">const</span><span style=\"color: #6688CC\"> </span><span style=\"color: #DDBB88\">deepCopyFunc</span><span style=\"color: #6688CC\"> </span><span style=\"color: #225588\">=</span><span style=\"color: #6688CC\"> </span><span style=\"color: #2277FF\">child</span><span style=\"color: #6688CC\"> </span><span style=\"color: #9966B8\">=&gt;</span><span style=\"color: #6688CC\"> {</span>\n<span style=\"color: #6688CC\">    </span><span style=\"color: #9966B8\">let</span><span style=\"color: #6688CC\"> parent, value, key</span>\n<span style=\"color: #6688CC\">    </span><span style=\"color: #225588\">if</span><span style=\"color: #6688CC\"> (</span><span style=\"color: #225588\">typeof</span><span style=\"color: #6688CC\"> child </span><span style=\"color: #225588\">!==</span><span style=\"color: #6688CC\"> </span><span style=\"color: #22AA44\">\"object\"</span><span style=\"color: #6688CC\"> </span><span style=\"color: #225588\">||</span><span style=\"color: #6688CC\"> child </span><span style=\"color: #225588\">===</span><span style=\"color: #6688CC\"> </span><span style=\"color: #F280D0\">null</span><span style=\"color: #6688CC\">) {</span>\n<span style=\"color: #6688CC\">        </span><span style=\"color: #225588\">return</span><span style=\"color: #6688CC\"> child </span><span style=\"color: #223355\">// zwracamy jeśli jest typem prymitywnym  </span>\n<span style=\"color: #6688CC\">    }</span>\n<span style=\"color: #6688CC\">    parent </span><span style=\"color: #225588\">=</span><span style=\"color: #6688CC\"> </span><span style=\"color: #9966B8\">Array</span><span style=\"color: #6688CC\">.</span><span style=\"color: #DDBB88\">isArray</span><span style=\"color: #6688CC\">(child) </span><span style=\"color: #225588\">?</span><span style=\"color: #6688CC\"> [] </span><span style=\"color: #225588\">:</span><span style=\"color: #6688CC\"> {}</span>\n\n<span style=\"color: #6688CC\">    </span><span style=\"color: #223355\">//jeśli jest obiektem to iterujemy po każdym property  </span>\n<span style=\"color: #6688CC\">    </span><span style=\"color: #225588\">for</span><span style=\"color: #6688CC\"> (key </span><span style=\"color: #225588\">in</span><span style=\"color: #6688CC\"> child) {</span>\n<span style=\"color: #6688CC\">        value </span><span style=\"color: #225588\">=</span><span style=\"color: #6688CC\"> child[key]</span>\n<span style=\"color: #6688CC\">        </span><span style=\"color: #223355\">//jeśli wartość dla key jest obiektem to wykonujemy rekurencyjną kopie  </span>\n<span style=\"color: #6688CC\">        </span><span style=\"color: #225588\">if</span><span style=\"color: #6688CC\"> (value </span><span style=\"color: #225588\">!==</span><span style=\"color: #6688CC\"> </span><span style=\"color: #F280D0\">null</span><span style=\"color: #6688CC\"> </span><span style=\"color: #225588\">&&</span><span style=\"color: #6688CC\"> </span><span style=\"color: #225588\">typeof</span><span style=\"color: #6688CC\"> value </span><span style=\"color: #225588\">===</span><span style=\"color: #6688CC\"> </span><span style=\"color: #22AA44\">\"object\"</span><span style=\"color: #6688CC\">) {</span>\n<span style=\"color: #6688CC\">            parent[key] </span><span style=\"color: #225588\">=</span><span style=\"color: #6688CC\"> </span><span style=\"color: #DDBB88\">deepCopyFunc</span><span style=\"color: #6688CC\">(value)</span>\n<span style=\"color: #6688CC\">        } </span><span style=\"color: #225588\">else</span><span style=\"color: #6688CC\"> {</span>\n<span style=\"color: #6688CC\">            parent[key] </span><span style=\"color: #225588\">=</span><span style=\"color: #6688CC\"> value</span>\n<span style=\"color: #6688CC\">        }</span>\n<span style=\"color: #6688CC\">    }</span>\n<span style=\"color: #6688CC\">    </span><span style=\"color: #225588\">return</span><span style=\"color: #6688CC\"> parent</span>\n<span style=\"color: #6688CC\">}</span>\n\n<span style=\"color: #9966B8\">let</span><span style=\"color: #6688CC\"> originalArray </span><span style=\"color: #225588\">=</span><span style=\"color: #6688CC\"> [</span><span style=\"color: #F280D0\">37</span><span style=\"color: #6688CC\">, </span><span style=\"color: #F280D0\">3700</span><span style=\"color: #6688CC\">, {</span>\n<span style=\"color: #6688CC\">    hello: </span><span style=\"color: #22AA44\">\"world\"</span>\n<span style=\"color: #6688CC\">}]</span></code></pre>\n<p>Myślę, że artykuł okazał się pomocny, a moje objaśnienia niezbyt trudne. Jeśli zauważysz gdzieś błąd, proszę, napisz do mnie. Zależy mi, by mój blog był rzetelnym źródłem informacji, więc z chęcią przyjmuję krytykę.</p>\n","excerpt":"Kopiowanie to mechanizm tworzenia duplikatów. W przypadku prymitywów (string, number, boolean itd) sprawa jest prosta, możemy spokojnie wykonywać wszystkie operacje bez obaw o nadpisywanie oryginału.","description":"Opisuję metody wykonywania klonów obiektów","cover":"/images/posts/kopie/cover.jpg","timeToRead":4,"author":{"id":"Julia Glaszka","title":"Julia Glaszka"}}}]}}},"context":{}}