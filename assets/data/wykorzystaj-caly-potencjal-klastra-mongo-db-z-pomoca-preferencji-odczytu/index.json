{"hash":"731cf98d742da99ec97050cbeae5adfd8e8a6a14","data":{"post":{"title":"Wykorzystaj cały potencjał klastra MongoDB z pomocą preferencji odczytu","path":"/wykorzystaj-caly-potencjal-klastra-mongo-db-z-pomoca-preferencji-odczytu/","slug":"mongodb-read-preferences","datetime":"2021-11-15 18:37:24","content":"<h1 id=\"\"></h1>\n<p>Typowy produkcyjny klaster jest zbudowany z co najmniej jednego ReplicaSetu. To oznacza, że posiadamy co najmniej jeden węzeł Primary (realizujący zapisy i odczyty) i kilka Secondary (tylko do odczytu). Domyślne ustawienia konfiguracji sterowników kierują ruch wyłącznie do Primary, rezygnując z używania pozostałych hostów. To oznacza, że obciążony jest tylko jeden node, a reszta pozostaje bierna - zasoby pod względem load-balancingu są marnowane. W przypadku awarii Mastera tracimy też możliwość odczytów, które mogłyby być nadal realizowane przez Secondary.</p>\n<p>Zatem w jaki sposób można wymusić kierowanie ruchu do innych hostów niż Primary? Z pomocą przychodzą nam preferencje odczytu - tzw. <code>ReadPreference</code>. Posiada on różne tryby, pozwalające na wybranie algorytmu poszukiwania hosta, do którego wyślemy query.</p>\n<h2 id=\"konfiguracja-preferencji-odczytu-w-driverze\">Konfiguracja preferencji odczytu w driverze</h2>\n<p>Ustawienia <code>ReadPreference</code> można zdefiniować w kilku miejscach:</p>\n<ul>\n<li>na poziomie klastra:</li>\n</ul>\n<pre class=\"shiki\" style=\"background-color: #2e3440\"><code><span style=\"color: #8FBCBB\">MongoClient</span><span style=\"color: #D8DEE9FF\"> mongoClient </span><span style=\"color: #81A1C1\">=</span><span style=\"color: #D8DEE9FF\"> </span><span style=\"color: #8FBCBB\">MongoClients</span><span style=\"color: #81A1C1\">.</span><span style=\"color: #88C0D0\">create</span><span style=\"color: #ECEFF4\">(</span><span style=\"color: #8FBCBB\">MongoClientSettings</span><span style=\"color: #81A1C1\">.</span><span style=\"color: #88C0D0\">builder</span><span style=\"color: #ECEFF4\">()</span><span style=\"color: #D8DEE9FF\">  </span>\n<span style=\"color: #D8DEE9FF\">.</span><span style=\"color: #88C0D0\">hosts</span><span style=\"color: #ECEFF4\">(</span><span style=\"color: #D8DEE9FF\">listOfHostsUrls</span><span style=\"color: #ECEFF4\">)</span>\n<span style=\"color: #D8DEE9FF\">.</span><span style=\"color: #88C0D0\">readPreference</span><span style=\"color: #ECEFF4\">(</span><span style=\"color: #8FBCBB\">ReadPreference</span><span style=\"color: #81A1C1\">.</span><span style=\"color: #88C0D0\">secondary</span><span style=\"color: #ECEFF4\">())</span><span style=\"color: #D8DEE9FF\">  </span>\n<span style=\"color: #D8DEE9FF\">.</span><span style=\"color: #88C0D0\">build</span><span style=\"color: #ECEFF4\">())</span><span style=\"color: #81A1C1\">;</span></code></pre>\n<ul>\n<li>na poziomie bazy danych</li>\n</ul>\n<pre class=\"shiki\" style=\"background-color: #2e3440\"><code><span style=\"color: #8FBCBB\">MongoDatabase</span><span style=\"color: #D8DEE9FF\"> database </span><span style=\"color: #81A1C1\">=</span><span style=\"color: #D8DEE9FF\"> mongoClient</span><span style=\"color: #81A1C1\">.</span><span style=\"color: #88C0D0\">getDatabase</span><span style=\"color: #ECEFF4\">(</span><span style=\"color: #ECEFF4\">\"</span><span style=\"color: #A3BE8C\">someDatabase</span><span style=\"color: #ECEFF4\">\"</span><span style=\"color: #ECEFF4\">)</span><span style=\"color: #D8DEE9FF\">  </span>\n<span style=\"color: #D8DEE9FF\">.</span><span style=\"color: #88C0D0\">withReadPreference</span><span style=\"color: #ECEFF4\">(</span><span style=\"color: #8FBCBB\">ReadPreference</span><span style=\"color: #81A1C1\">.</span><span style=\"color: #88C0D0\">secondary</span><span style=\"color: #ECEFF4\">())</span><span style=\"color: #81A1C1\">;</span></code></pre>\n<ul>\n<li>na poziomie kolekcji</li>\n</ul>\n<pre class=\"shiki\" style=\"background-color: #2e3440\"><code><span style=\"color: #8FBCBB\">MongoCollection&lt;Document&gt;</span><span style=\"color: #D8DEE9FF\"> collection </span><span style=\"color: #81A1C1\">=</span><span style=\"color: #D8DEE9FF\"> database</span><span style=\"color: #81A1C1\">.</span><span style=\"color: #88C0D0\">getCollection</span><span style=\"color: #ECEFF4\">(</span><span style=\"color: #ECEFF4\">\"</span><span style=\"color: #A3BE8C\">videos</span><span style=\"color: #ECEFF4\">\"</span><span style=\"color: #ECEFF4\">)</span><span style=\"color: #D8DEE9FF\">  </span>\n<span style=\"color: #D8DEE9FF\">.</span><span style=\"color: #88C0D0\">withReadPreference</span><span style=\"color: #ECEFF4\">(</span><span style=\"color: #8FBCBB\">ReadPreference</span><span style=\"color: #81A1C1\">.</span><span style=\"color: #88C0D0\">secondary</span><span style=\"color: #ECEFF4\">())</span><span style=\"color: #81A1C1\">;</span></code></pre>\n<p>Podane ustawienia mogą zmieniać działanie usługi, jeśli na przykład posiada na klastrze kilka różnych baz danych z różnymi kolekcjami. Może być tak, że nie dla wszystkich kolekcji można sobie pozwolić na odczyt z Secondary - np. gdy potrzebujemy wyższy poziom consistency.</p>\n<h2 id=\"tryby-odczytu\">Tryby odczytu</h2>\n<h3 id=\"primary\">primary</h3>\n<p>Domyślny dla wielu driverów. Kieruje ruch wyłącznie do hosta typu Primary, co może być znaczącą barierą w skalowaniu usługi pod kątem odczytów.</p>\n<h3 id=\"primarypreferred\">primaryPreferred</h3>\n<p>W tej preferencji w głównej mierze odczytujemy z hosta Primary, ale w przypadku gdy będzie niedostępny to odczyty zostaną przekierowana do innych replik typu Secondary.</p>\n<h3 id=\"secondary\">secondary</h3>\n<p>Wszystkie odczyty są kierowane do Secondary.</p>\n<h3 id=\"secondarypreferred\">secondaryPreferred</h3>\n<p>W większości przypadków odczytujemy z Secondary, ale przy awarii wszystkich hostów ruch może zostać przekierowany do Primary.</p>\n<h3 id=\"nearest\">nearest</h3>\n<p>Driver selekcjonuje zdrowe hosty z odpowiednio krótkim czasem odpowiedzi, tak by odpowiedziały maksymalnie szybko - np w ramach jednego datacenter. Następnie losowo wybierany jest jeden host, który zrealizuje żądanie. Nie jest uwzględniane czy node jest Primary czy Secondary.</p>\n<h2 id=\"jaki-tryb-odczytu-wybrać\">Jaki tryb odczytu wybrać?</h2>\n<p>W przypadku usługi typu heavy read z eventual consistency najbardziej optymalne będzie odczytywanie z preferencjami: <code>nearest</code>, <code>secondaryPreferred</code> lub <code>secondary</code>. Wybór konkretnej preferencji zależałby w tym przypadku od ilości zapisów oraz posiadanych hostów i zasobów. Jeśli usługa bardzo dużo zapisuje i Primary jest już dostatecznie obciążony, można rozważyć unikanie dociążania Primary poprzez preferencję <code>secondary</code> lub <code>secondaryPreferred</code>.</p>\n<p>Ostateczny wybór między pozostałymi dwoma typami odczytów może rozstrzygnąć to - czy bardziej zależy nam na stabilności odczytów czy zapisów. SecondaryPreferred dostarcza n+1 hostów, natomiast samo secondary tylko n (bo nie uwzględnia Primary).</p>\n<p>W sytuacji niespodziewanie większego ruchu warto mieć więcej dostępnych hostów niż mniej, ale analizując z drugiej strony - ten jeden dodatkowy host to Primary, jeśli zostanie obciążony to doprowadzi to również do niestabilności zapisów. Jeśli usługa nie posiada mechanizmów ponowień takich jak klienci z ponowieniami lub message queue, to dane mogą zostać niezapisane, co skłaniałoby do użycia preferencji secondary - wtedy awaria dotyczyłaby tylko odczytów.</p>\n<h2 id=\"po-wdrożeniu\">Po wdrożeniu</h2>\n<p>Po wdrożeniu nowego typu preferencji warto mieć wgląd w metryki:</p>\n<ul>\n<li>czasów odpowiedzi usługi</li>\n<li>czasów odpowiedzi bazy danych do usługi</li>\n<li>load, zajętość ramu, ilość rps do kolekcji, obciążenie sieciowe klastra mongo</li>\n</ul>\n<h2 id=\"podsumowanie\">Podsumowanie</h2>\n<p>Jak widać, każde takie ustawienie trzeba samodzielnie przeanalizować, uwzględniając swoje własne wymagania względem stabilności. Wybranie konkretnej preferencji odczytu może mieć dalekosiężne skutki, dlatego przed wyborem zawsze warto się dłużej zastanowić i przeanalizować słabe punkty konkretnego rozwiązania. Polecam również zapoznać się z <a href=\"https://docs.mongodb.com/manual/core/read-preference/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">oficjalną dokumentacją</a>.</p>\n","description":"MongoDB dostarcza wiele mechanizmów sterowania consistency. Jak uzyskać większą przepustowość odczytu kosztem spójności danych? O tym w dzisiejszym poście!","timeToRead":3,"cover":"/images/posts/mongodb-read-preferences/route.jpg","author":{"id":"Julia Glaszka","title":"Julia Glaszka"},"tags":[{"id":"mongodb","title":"mongodb","path":"/tag/mongodb/"},{"id":"java","title":"java","path":"/tag/java/"},{"id":"database","title":"database","path":"/tag/database/"}]},"recommendedposts":{"edges":[{"node":{"id":"5c6912511fbf00580160f309c8bff279","title":"Obiektywizm a rozwój w IT","path":"/obiektywizm-a-rozwoj-w-it/","cover":"/images/posts/obiektywizm/atlas.jpg"}},{"node":{"id":"507900b37c02db543d8fa26f4705fb1e","title":"Wykorzystaj cały potencjał klastra MongoDB z pomocą preferencji odczytu","path":"/wykorzystaj-caly-potencjal-klastra-mongo-db-z-pomoca-preferencji-odczytu/","cover":"/images/posts/mongodb-read-preferences/route.jpg"}},{"node":{"id":"c854d4a554f3e6aa74a421fac8beb243","title":"Konfiguracja ClusterSettings w MongoDB Java Driver","path":"/konfiguracja-cluster-settings-w-mongo-db-java-driver/","cover":"/images/posts/cluster-settings-mongo/adjusting.jpg"}}]}},"context":{}}